### 前端--Vue框架经典面试题

- 说一下 Vue 的生命周期

```js
1. beforeCreate 是 new Vue() 之后触发的第一个钩子，在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问

2. created 在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发 updated 函数。可以做一些初始数据的获取，在当前阶段无法与 Dom 进行交互，如果非要想，可以通过 vm.$nextTick 来访问 Dom

3. beforeMount 发生在挂载之前，在这之前 template 模版已导入渲染函数编译。而当前阶段虚拟 Dom 已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发 updated

4. mounted 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点，使用 $refs 属性对 Dom 进行操作

5. beforeUpdate 发生在更新之前，也就是响应式数据发生更新，虚拟 dom 重新渲染之前被触发，可以在当前阶段进行更改数据，不会造成重渲染

6. updated 发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新

7. beforeDestroy 发生在实例销毁之前，在当前阶段实例完全可以被使用，可以在这时进行善后收尾工作，比如清除计时器

8. destoryed 发生在实例销毁之后，这个时候只剩下了 Dom 空壳，组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁
```



- 说一下 Computed 和 Watch

```js
1. Computed 本质是一个具备缓存的 watcher，依赖的属性发生变化就会更新视图。适用于计算比较消耗性能的计算场景。当表达式过于复杂时，在模版中放入过多逻辑会让模版难以维护，可以将复杂的逻辑放入计算属性中处理

2. Watch 没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当需要深度监听对象中的属性时，可以打开 deep:true 选项，这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用字符串形式监听，如果没有写到组件中，不要忘记使用 unWatch 手动注销
```

